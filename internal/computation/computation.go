package computation

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"sync/atomic"
	"time"

	op "github.com/XJIeI5/calculator/internal/operation"
	"github.com/XJIeI5/calculator/internal/parser"
	pb "github.com/XJIeI5/calculator/proto"
	"github.com/gorilla/mux"
)

// func GetServer(addr string, port, maxGoroutines int) *http.Server {
// 	var (
// 		_addr string
// 	)
// 	if strings.Contains(addr, "localhost") || strings.Contains(addr, "127.0.0.1") {
// 		_addr = fmt.Sprintf(":%d", port)
// 	} else {
// 		_addr = fmt.Sprintf("%s:%d", addr, port)
// 	}

// 	return &http.Server{
// 		Addr:    _addr,
// 		Handler: newComputationServer(int32(maxGoroutines), fmt.Sprintf("%s:%d", addr, port)),
// 	}
// 	// return &ComputationServer{maxGoroutines: maxGoroutines}
// }

func newComputationServer(maxGoroutines int32, addr string) *computationServer {
	cs := &computationServer{
		maxGoroutines: maxGoroutines,
		addr:          addr,
	}
	r := mux.NewRouter()
	r.HandleFunc("/regist", cs.handleRegist).Methods("POST")
	cs.router = r
	return cs
}

type computationServer struct {
	addr              string
	storageAddr       string
	router            *mux.Router
	maxGoroutines     int32
	currentGoroutines int32
}

func (c *computationServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	c.router.ServeHTTP(w, r)
}

func (c *computationServer) handleRegist(w http.ResponseWriter, r *http.Request) {
	if t := r.Header.Get("Content-Type"); t != "application/json" {
		w.WriteHeader(http.StatusNoContent)
		return
	}
	type registerData struct {
		Addr string `json:"addr"`
	}

	storageData := registerData{}
	err := json.NewDecoder(r.Body).Decode(&storageData)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	autoGenerated := registerData{c.addr}
	data, err := json.Marshal(autoGenerated)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	resp, err := http.Post(fmt.Sprintf("%s/regist_compute", storageData.Addr), "application/json", bytes.NewBuffer(data))
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()
	w.WriteHeader(resp.StatusCode)
	c.storageAddr = storageData.Addr
	go c.beat()
}

func (c *computationServer) beat() {
	ticker := time.NewTicker(time.Second * 1)
	leaveStorage := func() {
		c.storageAddr = ""
		ticker.Stop()
	}
loop:
	for {
		select {
		case <-ticker.C:
			data := struct {
				Addr string `json:"addr"`
			}{
				Addr: c.addr,
			}
			b, _ := json.Marshal(data)
			resp, err := http.Post(fmt.Sprintf("%s/heart", c.storageAddr), "application/json", bytes.NewBuffer(b))
			if resp == nil {
				leaveStorage()
				break loop
			}
			if resp.StatusCode != http.StatusOK || err != nil {
				leaveStorage()
				break loop
			}
		}
	}
}

// for grpc
func GetServer(addr string, port, maxGoroutines int) *server {
	var _addr string
	if strings.Contains(addr, "localhost") || strings.Contains(addr, "127.0.0.1") {
		_addr = fmt.Sprintf(":%d", port)
	} else {
		_addr = fmt.Sprintf("%s:%d", addr, port)
	}
	return &server{
		addr:          _addr,
		maxGoroutines: int32(maxGoroutines),
	}
}

type server struct {
	pb.StorageServiceServer

	addr              string
	storageAddr       string
	router            *mux.Router
	maxGoroutines     int32
	currentGoroutines int32
}

func (s *server) Addr() string {
	return s.addr
}

func (s *server) Exec(ctx context.Context, req *pb.ExecRequest) (*pb.ExecResponce, error) {
	if atomic.LoadInt32(&s.currentGoroutines) >= int32(s.maxGoroutines) {
		return &pb.ExecResponce{}, fmt.Errorf("all the routines are busy")
	}
	atomic.AddInt32(&s.currentGoroutines, 1)

	defer atomic.AddInt32(&s.currentGoroutines, -1)

	timer := time.NewTimer(time.Millisecond * time.Duration(req.Duration))
	select {
	case <-timer.C:
		operand := parser.GetOperand(req.OpInfo.Op)
		if operand == nil {
			return &pb.ExecResponce{}, fmt.Errorf("operand '%s' doesn't exist", req.OpInfo.Op)
		}
		bin, ok := operand.(op.BinaryOperand)
		if !ok {
			return &pb.ExecResponce{}, fmt.Errorf("operand '%s' is not binary", operand.Symbol())
		}
		res, err := bin.Exec(float64(req.OpInfo.A), float64(req.OpInfo.B))
		if err != nil {
			return &pb.ExecResponce{}, err
		}
		return &pb.ExecResponce{Res: float32(res)}, nil
	case <-ctx.Done():
		return &pb.ExecResponce{}, fmt.Errorf("time's up")
	}
}

func (s *server) FreeProcesses(ctx context.Context, req *pb.FreeProcessesRequest) (*pb.FreeProcessesResponse, error) {
	select {
	case <-ctx.Done():
		return &pb.FreeProcessesResponse{}, fmt.Errorf("time's up")
	default:
		return &pb.FreeProcessesResponse{FreeProcesses: s.maxGoroutines - atomic.LoadInt32(&s.currentGoroutines)}, nil
	}
}
